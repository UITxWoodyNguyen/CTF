# Crack the Power
### Information
- Category: Cryptography
- Points: 200
- Level: Mediun
### Description
We received an encrypted message. The modulus is built from primes large enough that factoring them isnâ€™t an option, at least not today. See if you can make sense of the numbers and reveal the flag.

Check out the [`message.txt`](https://challenge-files.picoctf.net/c_amiable_citadel/fddf51f15bd9f4145c4a4ebee5dfe7994bdab6393453f41f02c59cfd23a87fda/message.txt)
### Hint
- When certain values in the encryption setup are smaller than usual, it opens up unexpected shortcuts to recover the plaintext
- Consider whether you can invert the encryption without factoring n.
- Read more about Coppersmith's_attack

## Solution
- The ciphertext c is an exact 20th power (e = 20) and c < n, so no modular reduction occurred. That means c = m^20 as an ordinary integer; the plaintext m is the integer 20th root of c. Taking the integer 20th root gives m, then interpreting m as ASCII (big-endian) yields the flag.
- Steps performed:
    - Checked sizes: `bit-length(n) = 4096`, `bit-length(c) = 3817`, so `c < n`.
    - Tested if `c` is a perfect 20th power: computed integer 20th root `r` and verified `r*20 = c`.
    - Converted `r` to bytes (big-endian) and decoded as UTF-8/ASCII.
- Here is the code base on the idea:
```python
# integer 20th root + decode
n = 533243488792862526372864876487972015558476758084609639178291036484536762505979244575533494210179721177427612771444407165530737395944304851576273837105495020943760864245479306542618510002482474205862628204754196547924816628892644743540164970080388264526664248913696849148511425119255713671555416474973315839345017109824349893148010866455964358290544676511280543217186127743655857081371266713418694384527145401015511524745607914050255166221258834450684893705781511821844099395903932453564599894459275163009075209010199883501651757350477674519968763648475565430724363201051610217288763953319606365780667742478503606233888576859352722076809743684159343050898842311263764404893493176121977631476550921422327027258721388423326937059110923457460318030756901735245816197255660210845666156979473229120283130937189483368618326646610727925656879968174934753321650897057490428159791619097768973322371191856903689557867217303295355238763695188844446446602773352153629404043068408327644141268659241706653484034372802622781271068072117494280260640208531182757711538823636556838888270621163106401504142980355241645849845227422621208433428766255132294103187339176714507386483525599169807412246213070204955287044372351174991253525495483482644039752259
e = 20
c = 640637430810406857500566702096274084238635318236179213474171471762962924031143406771762588590902396470755916529600404366017178856626504741264100246977770193177982321362431635239123331391332283310413781431317549724468046316011302717443301165248044916895605360942507583028357810072669019236437156021816483243897608716222651423340065746814875027190173089290179247176013883045798188232610328606575842929711953488636313111201073364434975416304861734107255474444898256437810232659581724786888468502454545178277401729068994688903655623034819685425430186901945673259366517562372649145103691296871839480367338134748035927612049747953193375204813837077096417935374925353519278729502554398818207750243092444833079944911226317963218327666226602587092863946963826671637061083175873944168270391171031158543469061673239737214705264979925667174942748269782844201684882259905429257929174592217288529234346005812956484839757692101317938929998836230049852549655586558526707728788020998340767097021929454867673939894353379731654252811545277025372592862223748563679444476115932107120123555249896845005062698950234571360385178811724060146325198188855919677023470832794001

# integer nth root function
def integer_nth_root(a, n):
    if a == 0: return 0, True
    low = 1
    high = 1 << ((a.bit_length() + n -1)//n + 1)
    while low <= high:
        mid = (low+high)//2
        p = mid**n
        if p == a:
            return mid, True
        if p < a:
            low = mid+1
        else:
            high = mid-1
    return high, False

r, ok = integer_nth_root(c, e)
assert ok and r**e == c
# decode
hexm = hex(r)[2:]
if len(hexm)%2: hexm = '0' + hexm
flag = bytes.fromhex(hexm).decode()
print(flag)  
```

**The flag is `picoCTF{t1ny_e_f053d79c}`**
